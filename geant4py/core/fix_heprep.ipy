import numpy as np
import re
from copy import deepcopy

common_words = ['"LVol"', '"Region"', '"RootRegion"', '"Solid"',
                '"EType"', '"Material"', '"Density"', '"State"',
                '"Radlen"', '"DrawAs"', '"LineColor"', '"Visibility"',
                '"Radius2"', '"Radius1"']


class Fix_heprep:
    def __init__(self, heprep_file, header_heprep_file, new_file_name=None):
        '''
        Fix_heprep: rewrites the heprep file to restructure it so types are
        entered first then instances are entered.
        Fix_heprep also strips the first 27 lines from the Fermi example and
        appends it to the front of the heprep file.

        Parameters:
        heprep_file is the generated heprep file from geant4py
        header_heprep_file is an example heprep file from Fermi Lab.
        new_file_name is the desired name of the new file
        (ie 'murs_geometry.heprep')
        '''

        self.heprep_file = heprep_file
        self.header_heprep_file = header_heprep_file
        self.new_file_name = new_file_name

    def cleaned_heprep_file(self):
        '''
        cleaned_heprep_file generates the corrected version of the heprep
        file that is viewable in ParaView
        Gathering information from old heprep
        '''

        old_lines, header_lines = copy_heprep_file(self.heprep_file,
                                                    self.header_heprep_file)
        layer_points, counter, type_num, layer_cnt = data_positions(old_lines)
        old_lines_heprep = collect_heprep_info(old_lines, layer_points,
                                               counter,
                                               common_words)

        # Start writing new heprep file
        old_lines_types, \
            new_lines, \
            counter_new = add_types_to_new_heprep(header_lines,
                                                  old_lines_heprep,
                                                  layer_points,
                                                  type_num,
                                                  layer_cnt,
                                                  counter)
        instances_new_lines = add_instances_to_new_heprep(old_lines_types,
                                                          new_lines,
                                                          layer_points,
                                                          counter_new,
                                                          layer_points)
        final_header_lines = fix_header_name(instances_new_lines, layer_points)
        write_new_heprep_file(new_lines,
                              fname_new=self.new_file_name)


def copy_heprep_file(heprep_file, header_heprep_file):
    '''
    copy_heprep_file copies the first 4 lines from an example heprep file and
    then appends
    the lines from the heprep file of interest starting at line 3.
    heprep_file: file to be fixed
    header_heprep_file: example header file
    '''
    with open(heprep_file, 'r') as infile:
        old_lines = [l.rstrip('\n') for l in infile]
    with open(header_heprep_file, 'r') as infile:
        file_header = [l.rstrip('\n') for l in infile]

    new_lines = deepcopy(file_header[0:4]+old_lines[3:])
    lines_removed = remove_words(new_lines)
    header_lines = deepcopy(file_header)
    return lines_removed, header_lines


def fix_header_name(header_lines, geo_names):
    # Rename geometry in old example heprep with first geometry name from
    # heprep file
    for idx, l in enumerate(header_lines):
        split = re.split('\s|(?<!\d)["=](?!\d)|"', l)
        if '<type' in split:
            header_lines[idx] = '<type name="'+geo_names[0]['Geo_name'][0]+'">'
            break
    return header_lines


def remove_words(new_lines):
    '''
    remove_words takes lines from copy_heprep_file and strips away three
    different phrases
    '''
    new_lines = [l.replace('showLabel="NONE"', "") for l in new_lines]
    new_lines = [l.replace('version="null"', "") for l in new_lines]
    new_lines = [l.replace('heprep:', "") for l in new_lines]
    return new_lines


def isfloat(value):
    '''
    isfloat takes a value and determines if it is a float or not
    '''
    try:
        float(value)
        return True
    except ValueError:
        return False


def data_positions(old_lines):
    '''
    data_positions finds the starting and ending positions of each type
    geometry
    Parameters:
    old_lines - is from the heprep file generated by geant4py
    '''
    type_num = 0
    layer_cnt = 0
    layer_num = []
    counter = []
    type_counter = []
    layer_num.append(0)
    drawAs_list = []
    drawAs_list.append(0)
    radius_list = []
    radius2_list = []
    geo_names = []
    radius_list.append(0)
    radius2_list.append(0)
    reset_radius = 0
    for cnt, l in enumerate(old_lines):
        line_split = re.split('\s|(?<!\d)["=/](?!\d)|"', l)
        if '<instance>' in line_split:
            counter.append(cnt)  # counting all the instances
        elif 'Layer' in line_split:
            value_n_line = old_lines[cnt+1]
            radius_list.append(0)  # radii will occur at the same frequency
            # as layers so this stores the radius as 0 if radius is not found
            radius2_list.append(0)
            if isfloat(value_n_line[value_n_line.find('value') + 7]) is True:
                layer_num.append(np.float(
                    value_n_line[value_n_line.find('value') + 7]))
                layer_cnt += 1
            reset_radius = 1
        elif 'DrawAs' in line_split:
            shape_n_line = re.split('\s|(?<!\d)["=/](?!\d)|"',
                                    old_lines[cnt+1])
            drawAs_list.append(shape_n_line[shape_n_line.index('value') + 2])
        elif ('Radius1' in line_split):
            if reset_radius == 1:
                radius_n_line = re.split('\s|(?<!\d)["=/](?!\d)|"',
                                         old_lines[cnt+1])
                radius_list[-1] = radius_n_line[radius_n_line.index('value') + 2]
            else:
                radius_n_line = re.split('\s|(?<!\d)["=/](?!\d)|"',
                                         old_lines[cnt+1])
                radius_list[-1] = radius_n_line[radius_n_line.index('value') + 2]
        elif ('Radius2' in line_split):
            if reset_radius == 1:
                radius_n_line = re.split('\s|(?<!\d)["=/](?!\d)|"',
                                         old_lines[cnt+1])
                radius2_list[-1] = radius_n_line[radius_n_line.index('value') + 2]
                reset_radius = 0
            else:
                continue
        elif '<type' in line_split:
            type_counter.append(cnt)
            type_num += 1
            if ('<type' in line_split) & ('name' in line_split):
                Start = ''
                End = '>'
                pos = 2
                name_list = []
                while Start != End:
                    name_list.append(line_split[line_split.index('name')
                                                + pos])
                    pos += 1
                    Start = line_split[line_split.index('name') + pos]
                geo_names.append(' '.join(name_list))
    counter.append(cnt)
    type_counter.append(cnt)

    # Check to see if layer information and types match up. If not, make them
    # align and update the geometry information
    if (type_num-1) != len(layer_num):
        old_lines, layer_numbers, \
            type_counter, geo_names = layers_equals_types(type_num,
                                                          layer_num,
                                                          old_lines,
                                                          geo_names)

    layer_points = collect_points(counter, old_lines, layer_num, drawAs_list,
                                  radius_list, radius2_list, geo_names)
    return layer_points, type_counter, type_num, layer_cnt


def collect_points(counter, old_lines, layer_num, drawAs_list, radius_list,
                   radius2_list,
                   geo_names):
    '''
    collect_points finds and stores all of the points for the objects in an
    ordered list
    '''
    x = []
    y = []
    z = []
    x.append(1e6)
    y.append(1e6)
    z.append(1e6)
    difference = np.diff(counter)
    layer_points = []
    for i, (cnt, diff) in enumerate(zip(counter, difference)):
        skip = 0
        reset_radius = 0
        pnt_cnt_x = 0
        data_range = cnt + diff
        start = cnt
        while start < data_range:
            line_split = re.split('\s|(?<!\d)["<=/](?!\d)|"', old_lines[start])
            if 'Layer' in line_split:
                    reset_radius = 1

            elif 'Radius2' in line_split:
                if reset_radius == 1:
                    reset_radius = 0
            # This is maintaining there are only 2 points for
            # the cylinder. Heprep writes 4 points, but the
            # cylinder only needs a positive z and negative z
            if 'x' in line_split:
                if reset_radius == 0:
                    if pnt_cnt_x < 2:
                        x.append(float(line_split[line_split.index('x') + 2]))
                    else:
                        pass
                    pnt_cnt_x += 1
                else:
                    x.append(float(line_split[line_split.index('x') + 2]))
            if 'y' in line_split:
                y.append(float(line_split[line_split.index('y') + 2]))
            if 'z' in line_split:
                z.append(float(line_split[line_split.index('z') + 2]))
            start += 1
        points_combine = {'Layer': [layer_num[i]], 'Shape': [drawAs_list[i]],
                          'Points_x': x, 'Points_y': y, 'Points_z': z,
                          'Radius': [radius_list[i]], 'Radius2': [radius2_list[i]],
                          'Geo_name': [geo_names[i]]}
        x = []
        y = []
        z = []
        layer_points.append(points_combine)
    return layer_points


def collect_heprep_info(old_lines, layer_points, counter, common_words):
    '''
    collect_heprep_info collects the layer information and reformats the
    <instance types > so that the structure orders the instances based on
    layers.
    There is an assumption that Layer 0 encompasses Layer 1 which then
    encompasses Layer 2 and so on.
    If two consecutive layers equal each other then each layer instance is
    closed so one does not encompass the other but both will be encompassed by
    lower layer numbers. If the layer numbers start to increase after the
    consecutive layers then the last layer will encompass the following layers.
    new_lines: are cleaned lines from the heprep file
    counter: informs the program where the type instances occur
    common_words: words that occur in the heprep file that should be passed
    '''
    difference = np.diff(counter)
    value_store = []
    name_holder = []
    previous = -1
    name_holder.append(layer_points[0]['Geo_name'][0])

    for i, (cnt, diff) in enumerate(zip(counter, difference)):
        data_range = cnt + diff
        start = cnt
        # loop over the <type> information and only store relevant parts
        while start < data_range:
            line_split = re.split('\s|(?<!\d)[=>/](?!\d)', old_lines[start])
            # ignore any instances that have common words
            if ('<instance' in line_split):
                old_lines[start] = ' <instance type="' + \
                                layer_points[i]['Geo_name'][0] + '">'

            elif '"Layer"' in line_split:
                w = layer_points[i]['Layer'][0]
                # go one line back
                # for building geometries. Geometry names occur to lines back
                # from Layer information
                if (w in value_store) & (int(w) > previous):
                    try:
                        name_holder[int(w)] = layer_points[i]['Geo_name'][0]
                    except IndexError:
                        name_holder.append(layer_points[i]['Geo_name'][0])
                    old_lines[start-1] = ' <instance type="' +\
                                         "/".join(name_holder) + '">'
                elif (w in value_store) & (int(w) < previous):
                    name_holder[int(w):] = '' # clear the list
                    name_holder.append(layer_points[i]['Geo_name'][0])
                    old_lines[start-1] = ' <instance type="' +\
                                         "/".join(name_holder) + '">'
                elif (int(w) == previous):
                    name_holder[int(w)] = layer_points[i]['Geo_name'][0]
                    old_lines[start-1] = ' <instance type="' + \
                                         "/".join(name_holder) + '">'
                else:
                    name_holder.append(layer_points[i]['Geo_name'][0])
                    old_lines[start-1] = ' <instance type="' + \
                                         "/".join(name_holder) + '">'
                value_store.append(w)  # this is to check on the next pass thru
                previous = int(w)

            elif ('"True"' in line_split) or ('"False"' in line_split):
                split = re.split('\s|(?<!\d)["=](?!\d)|"', old_lines[start])
                if '"True"' in line_split:
                    split[split.index('value') + 2] = "true"
                elif '"False"' in line_split:
                    split[split.index('value') + 2] = "false"
                old_lines[start] = 'type="boolean" value="' + \
                                   str(split[split.index('value') + 2] + '"/>')
            elif ('"State"' in line_split):
                old_lines[start+1] = 'value="Solid"/>'  # moving one line ahead
            start += 1

    return old_lines


def add_types_to_new_heprep(new_lines,
                            old_lines,
                            layer_points,
                            type_num,
                            layer_num,
                            counter):
    '''
    add_types_to_new_heprep restructures the type information so it is separate
    from the instances. It structures them based on layer information.
    Layer 0 encapsulates Layer 1 and Layer 1 encapsulates Layer 2 and so on
    '''
    difference = np.diff(counter)
    type_counter = []
    value_store = []
    name_holder = []
    previous = -1
    for i, (cnt, diff) in enumerate(zip(counter, difference)):
        reset_radius = 0
        skip = 0

        data_range = cnt + diff
        start = cnt
        lines_added = 0  # finding how many lines are added in types, because
        # the types will be closed after they are read in so the program will
        # need to go back by the # added and close the type
        while start < data_range:
            split = re.split('\s|(?<!\d)["=](?!\d)|"', old_lines[start])
            if ('Detector' in split) or ('Geometry' in split) or \
                ('<instance' in split) or ('<point' in split) or \
                ('</point>' in split) or ('</primitive>' in split) or \
                ('<primitive>' in split) or ('</instance>' in split) or \
                    ('</type>' in split):
                pass
            # ==========priming the environment to skip Detector Geometry and
            # world and add the
            # type at the end since these geometries encompass everything
            else:
                if 'Layer' in split:
                    reset_radius = 1
                elif 'Radius1' in split:
                    # This check is overwriting the old radius assuming
                    # the heprep file wrote in more than one Radius1.
                    # Will need to update it for a cone
                    if reset_radius == 0:
                        skip = 1
                        new_lines[-4] = old_lines[start]
                        new_lines[-3] = old_lines[start+1]
                elif 'Radius2' in split:
                    if reset_radius == 1:
                        reset_radius = 0
                if skip == 1:
                    pass
                else:
                    new_lines.append(old_lines[start])  # adding in relevant lines
                    lines_added += 1
            start += 1

        w = layer_points[i]['Layer'][0]
        line_2_add = int(len(new_lines) - lines_added - 1)  # go back one
        # position to put it behind the type it should close

        if (w in value_store) & (int(w) > previous):
            try:
                name_holder[int(w)] = layer_points[i]['Geo_name'][0]
            except IndexError:
                name_holder.append(layer_points[i]['Geo_name'][0])

        elif (w in value_store) & (int(w) < previous):
            for type_clos in range(int(len(name_holder) - w)):
                new_lines[line_2_add] = new_lines[line_2_add].replace(
                            new_lines[line_2_add],
                            new_lines[line_2_add] + '\n </type>')
            name_holder[int(w):] = ''  # clear the list
            name_holder.append(layer_points[i]['Geo_name'][0])
            value_store[int(w):] = ''
            value_store.append(w)

        elif (int(w) == previous):
            new_lines[line_2_add] = new_lines[line_2_add].replace(
                            new_lines[line_2_add],
                            new_lines[line_2_add] + '\n </type>')
            type_counter.append(1)
            name_holder[int(w)] = layer_points[i]['Geo_name'][0]

        else:
            name_holder.append(layer_points[i]['Geo_name'][0])
            pass
        value_store.append(w)  # this is to check on the next pass thru
        previous = int(w)

    for i in range(int(len(name_holder))):
        # closing all the geometries that encompass other geometries
        new_lines.append('</type>')
    new_lines.append('</typetree>')  # closing the geometry tree
    return old_lines, new_lines, counter


def add_instances_to_new_heprep(old_lines, new_lines, layer_numbers, counter,
                                layer_info):
    '''
    add_instances_to_new_heprep restructures the instance information so it is
    separate from the types. It structures them based on layer information.
    Layer 0 encapsulates Layer 1 and Layer 1 encapsulates Layer 2 and so on
    It also reads in the point information. Right now it assumes no geometry
    will exceed 8 points (ie no shape will have more than 8 sides.
    This will need to be updated as more complex geometries are added.)
    '''
    new_lines.append('<instancetree name="G4GeometryData"')
    new_lines.append('typetreename="G4GeometryTypes" typetreeversion="1.0" \
                     version="1.0">')
    lines = []

    for index, l in enumerate(old_lines):
        split = re.split('\s|(?<!\d)["=](?!\d)|"', l)
        if '<instance' in split:
            lines.append(old_lines[index])

    for idx in range(len(layer_info)):
        if len(layer_info[idx]['Points_x']) > 8:
            # Polygons and cylinders need to be opened twice by an instance
            # opening the new_line here because a check will be done to see if
            # the polygon is actually a prism.
            new_lines.append(lines[idx])
            # Maybe consider doing a for loop that groups the data together and
            # then checks if one list is a subset of the other. Right now, only
            # one match could be considered a match
            # This checks if one list is a subset of the other
            if (set(layer_info[idx - 1]['Points_x']) <=
                set(layer_info[idx]['Points_x'])) & \
               (set(layer_info[idx - 1]['Points_y']) <=
                set(layer_info[idx]['Points_y'])) & \
                (set(layer_info[idx - 1]['Points_z']) <=
                 set(layer_info[idx]['Points_z'])):
                    if len(layer_info[idx - 1]['Points_x']) == 8:
                        layer_info[idx]['Shape'] = layer_info[idx - 1]['Shape']
                        layer_info[idx]['Points_x'] = \
                            layer_info[idx - 1]['Points_x']
                        layer_info[idx]['Points_y'] = \
                            layer_info[idx - 1]['Points_y']
                        layer_info[idx]['Points_z'] = \
                            layer_info[idx - 1]['Points_z']
                        positions = Poly_2_Prism(new_lines)
                        new_lines[positions[idx]] = \
                            new_lines[positions[idx]].replace(
                            new_lines[positions[idx]],
                            'value="Prism"/>')
                        for i in range(8):
                            new_lines.append('<point x="' +
                                             str(layer_info[idx]['Points_x'][i]) +
                                             '" y="' +
                                             str(layer_info[idx]['Points_y'][i]) +
                                             '" z="' +
                                             str(layer_info[idx]['Points_z'][i]) +
                                             '"/>')
                        new_lines.append('</instance>')
                    else:
                        assert False  # not sure how to handle this
            elif len(layer_info[idx]['Points_x']) % 3 == 0 and \
                    layer_info[idx]['Shape'][0] == 'Polygon':
                new_lines.append(lines[idx])
                for i in range(len(layer_info[idx]['Points_x'])):
                    new_lines.append('<point x="' +
                                     str(layer_info[idx]['Points_x'][i]) +
                                     '" y="' +
                                     str(layer_info[idx]['Points_y'][i]) +
                                     '" z="' +
                                     str(layer_info[idx]['Points_z'][i])+'"/>')
                    if (i + 1) % 3 == 0:
                        if (i+1) == len(layer_info[idx]['Points_x']):
                            new_lines.append('</instance>')
                            new_lines.append('</instance>')
                        else:
                            new_lines.append('</instance>')
                            new_lines.append('</instance>')
                            new_lines.append(lines[idx])
                            new_lines.append(lines[idx])
            else:
                assert False  # Not sure how to handle this yet
        elif layer_info[idx]['Shape'][0] == 'Prism':
            new_lines.append(lines[idx])
            for i in range(len(layer_info[idx]['Points_x'])):
                new_lines.append('<point x="' +
                                 str(layer_info[idx]['Points_x'][i]) +
                                 '" y="' +
                                 str(layer_info[idx]['Points_y'][i]) +
                                 '" z="' +
                                 str(layer_info[idx]['Points_z'][i])+'"/>')
            new_lines.append('</instance>')
        elif layer_info[idx]['Shape'][0] == 'Cylinder':
            if (float(layer_info[idx]['Radius'][0]) ==
               float(layer_info[idx]['Radius2'][0])):
                layer_info[idx]['Radius'][0] = (float(layer_info[idx]['Radius2'][0]) -
                                                float(layer_info[idx]['Radius'][0]))
            new_lines.append(lines[idx])
            new_lines.append(lines[idx])
            new_lines.append('<attvalue name="Radius"' + ' type="double"' +
                             ' value="' +
                             str(layer_info[idx]['Radius'][0])+'"/>')
            for i in range(len(layer_info[idx]['Points_x'])):
                    new_lines.append('<point x="' +
                                     str(layer_info[idx]['Points_x'][i]) +
                                     '" y="' +
                                     str(layer_info[idx]['Points_y'][i]) +
                                     '" z="' +
                                     str(layer_info[idx]['Points_z'][i])+'"/>')
            new_lines.append('</instance>')
            new_lines.append(lines[idx])
            new_lines.append('<attvalue name="Radius"' + ' type="double"' +
                             ' value="' +
                             str(layer_info[idx]['Radius2'][0])+'"/>')
            for i in range(len(layer_info[idx]['Points_x'])):
                    new_lines.append('<point x="' +
                                     str(layer_info[idx]['Points_x'][i]) +
                                     '" y="' +
                                     str(layer_info[idx]['Points_y'][i]) +
                                     '" z="' +
                                     str(layer_info[idx]['Points_z'][i])+'"/>')
            new_lines.append('</instance>')
            new_lines.append('</instance>')
        elif layer_info[idx]['Shape'][0] == 0:
            new_lines.append(lines[idx])
            pass
        else:
            assert False  # Not sure how to handle this yet
    # closing all the geometries that encompass other geometries
    new_lines.append('</instance>')
    new_lines.append('</instancetree>')
    new_lines.append('</heprep>')
    return new_lines


def Poly_2_Prism(new_lines):
    '''
    type_positions finds the starting and ending positions of each type
    geometry
    Parameters:
    old_lines - is from the heprep file generated by geant4py
    '''
    positions = []
    positions.append(0)
    for cnt, l in enumerate(new_lines):
        line_split = re.split('\s|(?<!\d)["=/](?!\d)|"', l)
        if 'DrawAs' in line_split:
            positions.append(cnt+1)
    return positions


def write_new_heprep_file(new_lines, fname_new=None):
    with open(fname_new, 'w') as infile:
        infile.write('\n'.join(new_lines) + '\n')
    print('Done')


def layers_equals_types(type_num, layer_num, old_lines, geo_names):
    '''
    layers_equals_types checks to make sure that the layer numbers correctly
    corresponds with the types. If they do not correspond, the code goes
    through and places in type information.
    It assumes the last type matches with all the remaining types after it.
    copied and cleaned lines from the heprep file
    it also compares the number of layers to the number of types. If the
    2 are not equal
    '''
    equal_names = 0
    unequal_names = 0
    new_name = []
    first_instances = 0
    previous_layer = 0
    previous_name = ""
    geo_name = ""
    # picking a large number so it does not interfere with another label
    # depending on geometry
    unique_name_label = 100
    # setup
    layer_numbers = []  # create layer_numbers with the correct list size
    layer_numbers.append(0)  # Accounts for Detector Geometry
    for idx, l in enumerate(old_lines):
        split = re.split('\s|(?<!\d)["=](?!\d)|"', l)
        if '<type' in split:
            if first_instances <= 1:  # skip detector and world
                first_instances += 1
                pass
            elif 'name' in split:
                geo_name = split[split.index('name')+2]
                type_name = old_lines[idx]
                instance_name = old_lines[idx+1]
            previous_name = geo_name
        elif 'Layer' in split:
            layer = (re.split('"|"', old_lines[idx+1]))
            for w in layer:
                if (str(isfloat(w)) == 'True'):
                    current_layer = w
                    layer_numbers.append(float(w))
            single_split = re.split('\s|(?<!\d)["=](?!\d)|"',
                                    old_lines[idx - 2])
            # Add in unique identifiers for geometry
            # According to plugin, no geometries can have the same path.
            if ('name' not in single_split) & (previous_layer ==
                                               current_layer) & \
                                              (previous_name == geo_name):
                index = type_name.find('">')
                index_instance = instance_name.find('">')
                output_type = type_name[:index] + str(unique_name_label) \
                    + type_name[index:]
                output_instance = instance_name[:index_instance] + \
                    str(unique_name_label) + instance_name[index_instance:]
                unique_name_label += 1
                old_lines[idx-2] = \
                    old_lines[idx-2].replace(old_lines[idx-2], output_type)
                old_lines[idx-1] = \
                    old_lines[idx-1].replace(old_lines[idx-1],
                                             output_instance)
                equal_names = 1
            elif ('name' not in single_split) & (float(previous_layer) >
                                               float(current_layer)):
                    # if previous_layer is bigger than current layer they are
                    # not the same material so the material needs to be renamed
                    # Find where the last name occurred in geo names and then
                    # insert the new name after that
                    new_name.append(geo_names.index(geo_name) + 1)
                    lvol_split = re.split('\s|(?<!\d)["=](?!\d)|"',
                                    old_lines[idx +3 ])
                    # Rename the last geo_name with the logic volume name
#                     geo_names.insert(new_name, lvol_split[lvol_split.index('value') + 2])
                    unique_name_label += 1
                    unequal_names = 1
            elif 'name' in single_split:
                    pass
            else:
                assert False  # ('Not sure how to handle this yet')
            previous_layer = current_layer
#         elif 'LVol' in split:
#             print(old_lines[idx+1])

    # updating the name list
    # Assuming the last name in geo_names is the object that needs to be
    # updated
    if equal_names == 1:
        unique_name = geo_names[-1]
        for i in range(100, unique_name_label):
            geo_names.append(unique_name+str(i))
    elif unequal_names == 1:
        for i, j in zip(range(100, unique_name_label), new_name):
            unique_name = geo_names[j]
            geo_names.insert(j, unique_name+str(i))
            add_type_positions(old_lines, geo_names, j)
    else:
        pass
    # Use type information to update now where all the types occur.
    counter = type_positions(old_lines)
    return old_lines, layer_numbers, counter, geo_names


def type_positions(old_lines):
    '''
    type_positions finds the starting and ending positions of each type
    geometry
    Parameters:
    old_lines - is from the heprep file generated by geant4py
    '''
    type_num = 0
    layer_num = 0
    counter = []
    for cnt, l in enumerate(old_lines):
        line_split = l.split(' ')
        if '<type' in line_split:
            counter.append(cnt)
            type_num += 1
        elif 'name="Layer"' in line_split:
            layer_num += 1
    counter.append(cnt)

    return counter


def add_type_positions(old_lines, geo_names, position):
    '''
    add_type_positions adds in new type information if a new geometry name
    needed
    to be added in
    Parameters:
    old_lines - is from the heprep file generated by geant4py
    '''
    type_occurrence = 0
    layer_occurrence = 0
    # Creating a loop that checks for every name there is a corresponding
    # layer. If there is not a name, it inserts it in the file.
    for cnt, l in enumerate(old_lines):
        line_split = l.split(' ')
        if '<type' in line_split:
            type_occurrence += 1
            layer_occurrence = 0
        elif 'name="Layer"' in line_split:
            if (type_occurrence == 0) & (layer_occurrence == 1):
                old_lines[cnt] = old_lines[cnt].replace(
                            old_lines[cnt], '<type name="'+str(geo_names[position])+'"> \n' +
                            old_lines[cnt])
            type_occurrence = 0
            layer_occurrence += 1
